# Практическое задание №3. Реализация паттерна Saga для управления транзакциями в микросервисах


## 1. Цель работы

Научиться применять паттерн Saga для обеспечения согласованности данных между несколькими микросервисами в распределенной системе. На практике реализовать обработку бизнес-процесса "Заказ-Платеж", включающего шаги в разных сервисах и механизм компенсации при сбоях.

## 2. Описание Задания

Вам предстоит разработать два простых микросервиса на Spring Boot (`order-service` и `payment-service`) и реализовать между ними взаимодействие с использованием паттерна Saga для обработки следующего сценария:

1.  `order-service` получает запрос на создание заказа.
2.  Заказ сохраняется в базе данных `order-service` со статусом `PENDING`.
3.  Запускается сага: инициируется процесс резервирования средств через `payment-service`.
4.  `payment-service` пытается зарезервировать средства:
    * **Успех:** Средства зарезервированы, статус платежа `RESERVED`. Сага уведомляет `order-service`.
    * **Неудача:** Средства не могут быть зарезервированы (например, недостаточно), статус платежа `FAILED`. Сага уведомляет `order-service`.
5.  `order-service` реагирует на результат от `payment-service`:
    * **При успехе:** Статус заказа меняется на `CONFIRMED` (или `PAYMENT_APPROVED`).
    * **При неудаче:** Запускается компенсирующая транзакция – статус заказа меняется на `CANCELLED_PAYMENT_FAILED`.

## 3. Шаги выполнения

### Шаг 0: Подготовка окружения

1.  **Создайте два Spring Boot проекта:** `order-service` и `payment-service` (используйте Spring Initializr).
2.  **Основные зависимости:**
    * Spring Web (или WebFlux)
    * Spring Data JPA
    * Драйвер для вашей БД (e.g., PostgreSQL)
    * Lombok (опционально)
    * Зависимости для обмена сообщениями (см. Шаг 4)
3.  **Настройте Docker Compose (рекомендуется):** Создайте `docker-compose.yml` для запуска базы данных (например, PostgreSQL) и брокера сообщений (Kafka или RabbitMQ).

### Шаг 1: Реализация базовой логики `order-service`

1.  **Модель данных:** Создайте сущность `Order` (JPA Entity) с полями: `id`, `userId`, `productId`, `amount`, `status` (enum: `PENDING`, `CONFIRMED`, `CANCELLED_PAYMENT_FAILED`).
2.  **Репозиторий:** Создайте Spring Data JPA репозиторий для `Order`.
3.  **API:** Создайте REST контроллер с эндпоинтом `POST /orders` для приема запросов на создание заказа.
4.  **Сервисный слой:** Реализуйте логику сохранения заказа с начальным статусом `PENDING`. **Важно:** После сохранения заказа должен инициироваться запуск саги (как именно - зависит от выбранного подхода в Шаге 3).

### Шаг 2: Реализация базовой логики `payment-service`

1.  **Модель данных:** Создайте сущность `Payment` с полями: `id`, `orderId`, `amount`, `status` (enum: `PENDING_RESERVATION`, `RESERVED`, `FAILED`).
2.  **Репозиторий:** Создайте репозиторий для `Payment`.
3.  **Сервисный слой:** Реализуйте метод `reservePayment(orderId, amount)`:
    * Сохраняет платеж со статусом `PENDING_RESERVATION`.
    * **Имитирует логику резервирования:** Например, если `amount > 1000`, имитируйте сбой (недостаточно средств).
    * Обновляет статус платежа на `RESERVED` (при успехе) или `FAILED` (при неудаче).
    * Возвращает результат операции (успех/неудача).
4.  **Компенсация (Заготовка):** Предусмотрите метод для возможной отмены резервирования (даже если в этом простом сценарии он не вызывается при *неудаче* резервирования, он понадобился бы при откате *последующих* шагов саги).

### Шаг 3: Выбор и настройка подхода Saga

Выберите один из подходов для реализации взаимодействия:

* **Вариант А: Хореография (Choreography)**
    * Используйте брокер сообщений (Kafka/RabbitMQ).
    * Добавьте зависимости: `spring-cloud-starter-stream-kafka` (или `-rabbit`).
    * Настройте биндинги (каналы `input`/`output`) в `application.yml` обоих сервисов для обмена событиями (`OrderCreatedEvent`, `PaymentReservedEvent`, `PaymentFailedEvent`).
    * Переходите к **Шагу 4А**.

* **Вариант Б: Оркестрация (Orchestration)**
    * Решите, где будет находиться координатор: отдельный сервис или компонент внутри `order-service`.
    * Определите способ общения координатора с сервисами (REST или асинхронные команды через брокер).
    * Если используется брокер для команд/ответов, настройте соответствующие каналы.
    * Если используется REST, убедитесь, что сервисы предоставляют нужные эндпоинты.
    * Переходите к **Шагу 4Б**.

### Шаг 4А: Реализация Хореографии

1.  **`order-service`:**
    * После сохранения заказа (Шаг 1) опубликуйте `OrderCreatedEvent` в выходной канал Spring Cloud Stream.
    * Создайте `@StreamListener` (или `@Bean` типа `Consumer<>` в функциональном стиле) для прослушивания `PaymentReservedEvent` и `PaymentFailedEvent`.
    * В слушателе `PaymentReservedEvent` обновите статус заказа на `CONFIRMED`. Используйте `@Transactional`.
    * В слушателе `PaymentFailedEvent` обновите статус заказа на `CANCELLED_PAYMENT_FAILED` (это и есть компенсирующее действие для заказа). Используйте `@Transactional`.
2.  **`payment-service`:**
    * Создайте `@StreamListener` для `OrderCreatedEvent`.
    * В этом слушателе вызовите метод `reservePayment` (Шаг 2). Используйте `@Transactional`.
    * По результату `reservePayment` опубликуйте либо `PaymentReservedEvent`, либо `PaymentFailedEvent` в соответствующие выходные каналы.

### Шаг 4Б: Реализация Оркестрации

1.  **Координатор Саги (Saga Coordinator):**
    * Реализуйте логику управления состоянием саги. Можно использовать простую сущность `SagaState` (JPA Entity) для хранения `sagaId`, `orderId`, `currentStep`, `status` (RUNNING, COMPLETED, FAILED, COMPENSATING) и данных заказа.
    * При старте саги (после создания заказа) создайте запись `SagaState`.
    * Отправьте команду `ReservePaymentCommand` (через REST или брокер) в `payment-service`.
    * Обработайте ответ/событие от `payment-service` (`PaymentReservedEvent` / `PaymentFailedEvent`).
    * Если успех: Отправьте команду `ConfirmOrderCommand` в `order-service`. Обновите статус саги на `COMPLETED`.
    * Если неудача: Отправьте команду `CancelOrderCommand` (компенсация) в `order-service`. Обновите статус саги на `FAILED` / `COMPENSATED`.
    * Вся логика координатора должна быть отказоустойчивой (например, использовать персистентность состояния).
2.  **`order-service`:**
    * Предоставьте эндпоинты (или обработчики команд из брокера) для `ConfirmOrderCommand` (меняет статус на `CONFIRMED`) и `CancelOrderCommand` (меняет статус на `CANCELLED_PAYMENT_FAILED`). Методы должны быть `@Transactional`.
3.  **`payment-service`:**
    * Предоставьте эндпоинт (или обработчик команды) для `ReservePaymentCommand`. Он должен вызывать логику `reservePayment` и отправлять ответ/событие координатору (`PaymentReservedEvent` / `PaymentFailedEvent`). Метод должен быть `@Transactional`.

### Шаг 5: Реализация Идемпотентности

* **Проблема:** Сообщения в брокере могут доставляться повторно. Команды могут быть отправлены повторно при сбоях сети.
* **Решение:** Обеспечьте идемпотентность обработчиков сообщений/команд.
    * **Простой способ:** В сервисе, принимающем сообщение/команду, создайте таблицу `processed_messages` (message_id, timestamp). Перед обработкой сообщения проверяйте, нет ли его ID уже в таблице. Если нет – обрабатывайте и добавляйте ID в таблицу в рамках одной транзакции с основной логикой.
    * Примените этот механизм как минимум к обработчикам в `payment-service` (на `OrderCreatedEvent` или `ReservePaymentCommand`) и в `order-service` (на `PaymentReservedEvent`/`PaymentFailedEvent` или `ConfirmOrderCommand`/`CancelOrderCommand`).

### Шаг 6: Тестирование

1.  Запустите все компоненты (сервисы, БД, брокер).
2.  Отправьте запрос на создание заказа в `order-service` с суммой, которая должна пройти успешно (например, <= 1000). Проверьте:
    * Статус заказа в `order-service` стал `CONFIRMED`.
    * Статус платежа в `payment-service` стал `RESERVED`.
    * В логах видна последовательность шагов саги.
3.  Отправьте запрос на создание заказа с суммой, которая должна вызвать сбой (например, > 1000). Проверьте:
    * Статус заказа в `order-service` стал `CANCELLED_PAYMENT_FAILED`.
    * Статус платежа в `payment-service` стал `FAILED`.
    * В логах виден запуск компенсации.
4.  (Дополнительно) Попробуйте отправить одно и то же сообщение/команду дважды и убедитесь, что операция выполняется только один раз (проверка идемпотентности).

### Шаг 7: (Опционально) Улучшения

* Добавьте распределенную трассировку (Spring Cloud Sleuth / Micrometer Tracing) для отслеживания запроса по всем сервисам.
* Добавьте более детальное логирование с ID корреляции (sagaId/orderId).
* Реализуйте более сложный сценарий с большим количеством шагов и компенсаций.

## 4. Ожидаемый Результат

* Рабочие исходные коды двух микросервисов (`order-service`, `payment-service`) и, возможно, координатора (для оркестрации).
* Файл `docker-compose.yml` для запуска окружения.
* Код демонстрирует выбранный подход к реализации саги (Хореография или Оркестрация).
* Реализована обработка успешного сценария и сценария сбоя с компенсацией.
* Реализован механизм идемпотентности для обработчиков.

## 5. Технологии и Инструменты

* Java 17+ / Kotlin
* Spring Boot 3.x
* Maven / Gradle
* PostgreSQL / H2
* Kafka / RabbitMQ
* Docker, Docker Compose
* Spring Cloud Stream (для Хореографии)
* Spring Web, Spring Data JPA
