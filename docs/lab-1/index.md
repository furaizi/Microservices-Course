# Практическое задание №1. Взаимодействие микросервисов через REST API

## 1. Введение

Данная практическая работа предназначена для закрепления теоретических знаний, полученных по теме "Разбиение монолита на микросервисы". Целью работы является получение практических навыков декомпозиции простого монолитного приложения на два независимых микросервиса и реализация базового взаимодействия между ними с использованием REST API.

## 2. Описание Исходного Монолита (Концептуальное)

Представим себе простое монолитное веб-приложение для управления пользователями и их заказами. В рамках единого приложения реализованы следующие функции:

* **Управление пользователями:**
    * Создание нового пользователя (имя, email).
    * Получение информации о пользователе по его ID.
    * Получение списка всех пользователей.
    * Обновление данных пользователя.
    * Удаление пользователя.
* **Управление заказами:**
    * Создание нового заказа для конкретного пользователя (описание заказа, сумма).
    * Получение информации о заказе по его ID (включая ID пользователя, который сделал заказ).
    * Получение списка всех заказов.
    * Получение списка заказов для конкретного пользователя.

Вся логика и данные (например, в виде списков или словарей в памяти, или в единой БД) находятся в рамках одного приложения.

## 3. Задачи

Необходимо выполнить декомпозицию описанного концептуального монолита на два отдельных микросервиса:

1.  **Сервис Пользователей (`UserService`)**
2.  **Сервис Заказов (`OrderService`)**

Каждый микросервис должен быть реализован как отдельное, независимо запускаемое приложение.

### 3.1. Создать Сервис Пользователей (`UserService`)

* Реализовать функциональность для управления пользователями (CRUD - Create, Read, Update, Delete).
* Сервис должен хранить данные о пользователях независимо от других сервисов (например, в памяти процесса или в отдельном файле/БД).
* Каждый пользователь должен иметь уникальный идентификатор (`user_id`), имя и email.

### 3.2. Создать Сервис Заказов (`OrderService`)

* Реализовать функциональность для управления заказами (CRUD - Create, Read, Update, Delete).
* Сервис должен хранить данные о заказах независимо от других сервисов.
* Каждый заказ должен иметь уникальный идентификатор (`order_id`), описание, сумму и **идентификатор пользователя (`user_id`)**, которому принадлежит заказ.
* **Важно:** `OrderService` *не должен* хранить полную информацию о пользователе (имя, email), а только его `user_id`.

### 3.3. Реализовать REST API для каждого сервиса

* **`UserService`** должен предоставлять REST API для операций CRUD над пользователями. Например:
    * `POST /users` - создать пользователя
    * `GET /users/{user_id}` - получить пользователя по ID
    * `GET /users` - получить список всех пользователей
    * `PUT /users/{user_id}` - обновить пользователя
    * `DELETE /users/{user_id}` - удалить пользователя
* **`OrderService`** должен предоставлять REST API для операций CRUD над заказами. Например:
    * `POST /orders` - создать заказ (в теле запроса передается `user_id`, описание, сумма)
    * `GET /orders/{order_id}` - получить заказ по ID
    * `GET /orders` - получить список всех заказов
    * `GET /users/{user_id}/orders` - получить все заказы конкретного пользователя

### 3.4. Реализовать взаимодействие между сервисами

* Реализовать сценарий, при котором `OrderService` обращается к `UserService` для получения данных.
* **Конкретный сценарий:** При запросе на получение информации о конкретном заказе (`GET /orders/{order_id}`), `OrderService` должен:
    1.  Получить данные заказа из своего хранилища (включая `user_id`).
    2.  **Выполнить HTTP GET запрос к `UserService`** по адресу `GET /users/{user_id}` (используя `user_id` из данных заказа), чтобы получить имя и email пользователя.
    3.  Вернуть клиенту расширенную информацию о заказе, включающую как данные самого заказа, так и полученные данные пользователя (например, имя и email).
* *Опционально:* При создании заказа (`POST /orders`) реализовать проверку существования пользователя путем запроса к `UserService`.

### 3.5. Обеспечить независимый запуск сервисов

* Каждый сервис должен запускаться как отдельный процесс.
* Сервисы должны слушать разные порты (например, `UserService` на порту 8000, `OrderService` на порту 8001).
* Конфигурация (например, URL другого сервиса) должна быть легко изменяемой (например, через переменные окружения или конфигурационный файл).

## 4. Требования к реализации

* **Язык программирования и фреймворк:** На выбор студента (рекомендуемые: Python + Flask/FastAPI, Java + Spring Boot, Node.js + Express, Go + Gin/Echo). Необходимо указать выбор в документации.
* **Хранение данных:** Для упрощения допускается использование хранения данных в памяти (например, словари, списки в Python; `HashMap`, `ArrayList` в Java) или в простых файлах (JSON, CSV). Использование полноценных баз данных не требуется, но допускается. Главное – данные каждого сервиса должны быть изолированы.
* **Формат данных API:** JSON.
* **Обработка ошибок:** Реализовать базовую обработку ошибок (например, возврат 404 Not Found при запросе несуществующего ресурса, 400 Bad Request при некорректных входных данных, обработка ошибок при сетевом взаимодействии между сервисами).
* **Код:** Код должен быть чистым, структурированным и содержать комментарии при необходимости.
